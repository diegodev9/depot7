#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const service_1 = require("./service");
let service;
const connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
connection.onInitialize(async (params) => {
    service = new service_1.Service(connection, params);
    await service.init();
    const result = {
        capabilities: {
            textDocumentSync: node_1.TextDocumentSyncKind.Incremental,
            completionProvider: {
                resolveProvider: true,
            },
            codeActionProvider: true,
            definitionProvider: true,
            executeCommandProvider: {
                commands: [
                    "stimulus.controller.create",
                    "stimulus.controller.update",
                ],
            },
        },
    };
    if (service.settings.hasWorkspaceFolderCapability) {
        result.capabilities.workspace = {
            workspaceFolders: {
                supported: true,
            },
        };
    }
    return result;
});
connection.onInitialized(() => {
    if (service.settings.hasConfigurationCapability) {
        // Register for all configuration changes.
        connection.client.register(node_1.DidChangeConfigurationNotification.type, undefined);
    }
    if (service.settings.hasWorkspaceFolderCapability) {
        connection.workspace.onDidChangeWorkspaceFolders((_event) => {
            connection.console.log("Workspace folder change event received.");
        });
    }
    connection.client.register(node_1.DidChangeWatchedFilesNotification.type, {
        watchers: service.stimulusDataProvider.controllerRoots.map((root) => ({ globPattern: `**/${root}/**/*` })),
    });
});
connection.onDidChangeConfiguration((change) => {
    if (service.settings.hasConfigurationCapability) {
        // Reset all cached document settings
        service.settings.documentSettings.clear();
    }
    else {
        service.settings.globalSettings = ((change.settings.languageServerStimulus || service.settings.defaultSettings));
    }
    service.refresh();
});
connection.onDidOpenTextDocument((params) => {
    const document = service.documentService.get(params.textDocument.uri);
    if (document) {
        service.diagnostics.refreshDocument(document);
    }
});
connection.onDidChangeWatchedFiles(() => service.refresh());
connection.onDefinition((params) => service.definitions.onDefinition(params));
connection.onCodeAction((params) => service.codeActions.onCodeAction(params));
connection.onExecuteCommand((params) => {
    if (!params.arguments)
        return;
    if (params.command === "stimulus.controller.create") {
        const [identifier, diagnostic, controllerRoot] = params.arguments;
        service.commands.createController(identifier, diagnostic, controllerRoot);
    }
    if (params.command === "stimulus.controller.update") {
        const [identifier, diagnostic, suggestion] = params.arguments;
        service.commands.updateControllerReference(identifier, diagnostic, suggestion);
    }
});
connection.onCompletion((textDocumentPosition) => {
    const document = service.documentService.get(textDocumentPosition.textDocument.uri);
    if (!document)
        return null;
    return service.htmlLanguageService.doComplete(document, textDocumentPosition.position, service.htmlLanguageService.parseHTMLDocument(document));
});
// This handler resolves additional information for the item selected in
// the completion list.
connection.onCompletionResolve((item) => {
    var _a, _b, _c;
    if ((_a = item.data) === null || _a === void 0 ? void 0 : _a.detail)
        item.detail = item.data.detail;
    if ((_b = item.data) === null || _b === void 0 ? void 0 : _b.documentation)
        item.documentation = item.data.documentation;
    if ((_c = item.data) === null || _c === void 0 ? void 0 : _c.kind)
        item.kind = item.data.kind;
    return item;
});
// Listen on the connection
connection.listen();
//# sourceMappingURL=server.js.map