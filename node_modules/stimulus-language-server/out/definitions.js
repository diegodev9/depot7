"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Definitions = void 0;
const node_1 = require("vscode-languageserver/node");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const html_util_1 = require("./html_util");
class Definitions {
    constructor(documentService, stimulusDataProvider) {
        this.documentService = documentService;
        this.stimulusDataProvider = stimulusDataProvider;
    }
    get controllers() {
        return this.stimulusDataProvider.controllers;
    }
    onDefinition(params) {
        const uri = params.textDocument.uri;
        const textDocument = this.documentService.get(uri);
        if (!textDocument)
            return;
        const html = (0, vscode_html_languageservice_1.getLanguageService)().parseHTMLDocument(textDocument);
        const offset = textDocument.offsetAt(params.position);
        const node = html.findNodeAt(offset);
        const content = textDocument.getText();
        let identifier;
        let identifiers;
        const attributeStart = this.previousIndex(content, ["'", '"'], offset);
        const attributeEnd = this.nextIndex(content, ["'", '"'], offset);
        const value = content.substring(attributeStart, attributeEnd);
        if (!value.includes(" ")) {
            identifier = value;
        }
        else {
            identifier = value.substring(this.previousIndex(value, [" "], offset - attributeStart), this.nextIndex(value, [" "], offset - attributeStart));
        }
        if (this.controllers.map((controller) => controller.identifier).includes(identifier)) {
            identifiers = [identifier];
        }
        else {
            identifiers = (0, html_util_1.tokenList)(node, "data-controller");
        }
        const controllers = this.controllers.filter((controller) => identifiers.includes(controller.identifier));
        const locations = controllers.map((controller) => node_1.Location.create(controller.path, node_1.Range.create(0, 0, 0, 0)));
        if (controllers.length === 1)
            return locations[0];
        return locations;
    }
    nextIndex(string, tokens, offset) {
        const indexes = tokens.map((token) => string.indexOf(token, offset)).filter((i) => i !== -1);
        if (indexes.length === 0)
            return string.length;
        return Math.min(...indexes);
    }
    previousIndex(string, tokens, offset) {
        const indexes = tokens
            .map((token) => (0, html_util_1.reverseString)(string).indexOf(token, string.length - offset))
            .filter((i) => i !== -1)
            .map((i) => string.length - i);
        if (indexes.length === 0)
            return 0;
        return Math.min(...indexes);
    }
}
exports.Definitions = Definitions;
//# sourceMappingURL=definitions.js.map