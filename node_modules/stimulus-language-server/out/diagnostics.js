"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Diagnostics = void 0;
const node_1 = require("vscode-languageserver/node");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const action_descriptor_1 = require("./action_descriptor");
const html_util_1 = require("./html_util");
const utils_1 = require("./utils");
class Diagnostics {
    constructor(connection, stimulusDataProvider, documentService) {
        this.diagnosticsSource = "Stimulus LSP";
        this.diagnostics = new Map();
        this.controllerAttribute = "data-controller";
        this.actionAttribute = "data-action";
        this.targetAttribute = /data-(.+)-target/;
        this.valueAttribute = /data-(.+)-(.+)-value/;
        this.connection = connection;
        this.stimulusDataProvider = stimulusDataProvider;
        this.documentService = documentService;
    }
    get controllers() {
        return this.stimulusDataProvider.controllers;
    }
    get controllerIdentifiers() {
        return this.controllers.map((controller) => controller.identifier);
    }
    validateDataControllerAttribute(node, textDocument) {
        const identifiers = (0, html_util_1.tokenList)(node, this.controllerAttribute);
        const invalidIdentifiers = identifiers.filter((identifier) => !this.controllerIdentifiers.includes(identifier));
        invalidIdentifiers.forEach((identifier) => {
            const attributeValueRange = this.attributeValueRange(textDocument, node, this.controllerAttribute, identifier);
            this.createInvalidControllerDiagnosticFor(identifier, textDocument, attributeValueRange);
        });
    }
    validateDataActionAttribute(node, textDocument) {
        const actions = (0, html_util_1.tokenList)(node, this.actionAttribute);
        actions.forEach((action) => {
            const actionDescriptor = (0, action_descriptor_1.parseActionDescriptorString)(action);
            const { identifier, methodName } = actionDescriptor;
            if (!identifier || !methodName) {
                const attributeValueRange = this.attributeValueRange(textDocument, node, this.actionAttribute, action);
                this.createInvalidActionDiagnosticFor(action, textDocument, attributeValueRange);
                return;
            }
            const controller = this.controllers.find((controller) => controller.identifier === identifier);
            if (!controller) {
                const attributeValueRange = this.attributeValueRange(textDocument, node, this.actionAttribute, identifier);
                this.createInvalidControllerDiagnosticFor(identifier, textDocument, attributeValueRange);
            }
            if (controller && methodName && !controller.methods.includes(methodName)) {
                const attributeValueRange = this.attributeValueRange(textDocument, node, this.actionAttribute, methodName);
                this.createInvalidControllerActionDiagnosticFor(identifier, methodName, textDocument, attributeValueRange);
            }
        });
    }
    validateDataValueAttribute(node, textDocument) {
        const attributes = node.attributes || {};
        const valueAttributeNames = Object.keys(attributes).filter((attribute) => attribute.match(this.valueAttribute));
        valueAttributeNames.forEach((attribute) => {
            const value = (0, html_util_1.attributeValue)(node, attribute) || "";
            const attributeMatches = attribute.match(this.valueAttribute);
            // TODO: skip when value contains <%= or %>
            if (attributeMatches && Array.isArray(attributeMatches) && attributeMatches[1]) {
                let identifier = attributeMatches[1];
                let valueName = attributeMatches[2];
                let controller = this.controllers.find((controller) => controller.identifier === identifier);
                if (!controller) {
                    const identifierSplits = identifier.split("--");
                    let valuePart;
                    let namespacePart;
                    // has namespace
                    if (identifierSplits.length > 1) {
                        namespacePart = identifierSplits.slice(0, -1).join("--");
                        valuePart = identifierSplits[identifierSplits.length - 1];
                    }
                    else {
                        namespacePart = null;
                        valuePart = identifierSplits[0];
                    }
                    const allParts = valuePart.split("-").concat(valueName.split("-"));
                    for (let i = 1; i <= allParts.length; i++) {
                        if (controller)
                            continue;
                        let potentialIdentifier = allParts.slice(0, i).join("-");
                        if (namespacePart) {
                            potentialIdentifier = `${namespacePart}--${potentialIdentifier}`;
                        }
                        const potentialValueName = allParts.slice(i, allParts.length).join("-");
                        controller = this.controllers.find((controller) => controller.identifier === potentialIdentifier);
                        if (controller) {
                            identifier = potentialIdentifier;
                            valueName = potentialValueName;
                        }
                    }
                }
                if (!controller) {
                    const attributeNameRange = this.attributeNameRange(textDocument, node, attribute, identifier);
                    this.createInvalidControllerDiagnosticFor(identifier, textDocument, attributeNameRange);
                    return;
                }
                const hasUppercaseLetter = valueName.match(/[A-Z]/g);
                if (hasUppercaseLetter) {
                    const attributeNameRange = this.attributeNameRange(textDocument, node, attribute, valueName);
                    this.createAttributeFormatMismatchDiagnosticFor(identifier, valueName, textDocument, attributeNameRange);
                    return;
                }
                const camelizedValueName = (0, utils_1.camelize)(valueName);
                const valueDefiniton = controller.values[camelizedValueName];
                if (controller && !valueDefiniton) {
                    const attributeNameRange = this.attributeNameRange(textDocument, node, attribute, valueName);
                    this.createMissingValueOnControllerDiagnosticFor(identifier, camelizedValueName, textDocument, attributeNameRange);
                    return;
                }
                let actualType;
                const expectedType = valueDefiniton.type;
                try {
                    actualType = this.parseValueType(JSON.parse(value));
                }
                catch (e) {
                    try {
                        actualType = this.parseValueType(JSON.parse(`"${value}"`));
                    }
                    catch (e) {
                        actualType = (e === null || e === void 0 ? void 0 : e.message) || "unparsable";
                    }
                }
                if (actualType !== expectedType) {
                    const attributeValueRange = this.attributeValueRange(textDocument, node, attribute, value);
                    this.createValueMismatchOnControllerDiagnosticFor(identifier, camelizedValueName, expectedType, actualType, textDocument, attributeValueRange);
                }
            }
        });
    }
    validateDataClassAttribute(_node, _textDocument) {
        // TODO: implemenet
    }
    validateDataTargetAttribute(node, textDocument) {
        const attributes = node.attributes || {};
        const targetAttributeNames = Object.keys(attributes).filter((attribute) => attribute.match(this.targetAttribute));
        targetAttributeNames.forEach((attribute) => {
            const targetName = (0, html_util_1.attributeValue)(node, attribute) || "";
            const targetMatches = attribute.match(this.targetAttribute);
            const matchedTarget = targetMatches && Array.isArray(targetMatches);
            const identifier = matchedTarget && targetMatches[1];
            if (identifier) {
                const controller = this.controllers.find((controller) => controller.identifier === identifier);
                if (!controller) {
                    const attributeNameRange = this.attributeNameRange(textDocument, node, attribute, identifier);
                    this.createInvalidControllerDiagnosticFor(identifier, textDocument, attributeNameRange);
                    return;
                }
                if (controller && !controller.targets.includes(targetName)) {
                    const attributeNameRange = this.attributeValueRange(textDocument, node, attribute, targetName);
                    this.createMissingTargetOnControllerDiagnosticFor(identifier, targetName, textDocument, attributeNameRange);
                }
            }
        });
    }
    visitNode(node, textDocument) {
        this.validateDataControllerAttribute(node, textDocument);
        this.validateDataActionAttribute(node, textDocument);
        this.validateDataValueAttribute(node, textDocument);
        this.validateDataClassAttribute(node, textDocument);
        this.validateDataTargetAttribute(node, textDocument);
        node.children.forEach((child) => {
            this.visitNode(child, textDocument);
        });
    }
    validate(textDocument) {
        const service = (0, vscode_html_languageservice_1.getLanguageService)();
        const html = service.parseHTMLDocument(textDocument);
        html.roots.forEach((node) => {
            this.visitNode(node, textDocument);
        });
        this.sendDiagnosticsFor(textDocument);
    }
    refreshDocument(document) {
        this.validate(document);
    }
    refreshAllDocuments() {
        this.documentService.getAll().forEach((document) => {
            this.refreshDocument(document);
        });
    }
    rangeFromNode(textDocument, node) {
        return node_1.Range.create(textDocument.positionAt(node.start), textDocument.positionAt(node.startTagEnd || node.end));
    }
    attributeNameRange(textDocument, node, attribute, search) {
        const range = this.rangeFromNode(textDocument, node);
        const startTagContent = textDocument.getText(range);
        return this.rangeForAttributeName(textDocument, startTagContent, node, attribute, search);
    }
    rangeForAttributeName(textDocument, tagContent, node, attribute, search) {
        const searchIndex = attribute.indexOf(search) || 0;
        const attributeNameStartIndex = tagContent.indexOf(attribute);
        const attributeNameStart = node.start + attributeNameStartIndex + searchIndex;
        const attributeNameEnd = attributeNameStart + search.length;
        return node_1.Range.create(textDocument.positionAt(attributeNameStart), textDocument.positionAt(attributeNameEnd));
    }
    attributeValueRange(textDocument, node, attribute, search) {
        const range = this.rangeFromNode(textDocument, node);
        const startTagContent = textDocument.getText(range);
        return this.rangeForAttributeValue(textDocument, startTagContent, node, attribute, search);
    }
    rangeForAttributeValue(textDocument, tagContent, node, attribute, search) {
        const value = (0, html_util_1.attributeValue)(node, attribute) || "";
        const searchIndex = value.indexOf(search) || 0;
        const attributeStartIndex = tagContent.indexOf(attribute);
        const attributeValueStart = node.start + attributeStartIndex + attribute.length + searchIndex + 2;
        const attributeValueEnd = attributeValueStart + search.length;
        return node_1.Range.create(textDocument.positionAt(attributeValueStart), textDocument.positionAt(attributeValueEnd));
    }
    createInvalidControllerDiagnosticFor(identifier, textDocument, range) {
        const match = (0, utils_1.didyoumean)(identifier, this.controllers.map((controller) => controller.identifier));
        const suggestion = match ? `Did you mean "${match}"?` : "";
        this.pushDiagnostic(`"${identifier}" isn't a valid Stimulus controller. ${suggestion}`, "stimulus.controller.invalid", range, textDocument, { identifier, suggestion: match, textDocument, range });
    }
    createInvalidActionDiagnosticFor(action, textDocument, range) {
        this.pushDiagnostic(`"${action}" isn't a valid action descriptor`, "stimulus.action.invalid", range, textDocument, {
            action,
        });
    }
    createInvalidControllerActionDiagnosticFor(identifier, actionName, textDocument, range) {
        const controller = this.controllers.find((controller) => controller.identifier === identifier);
        const match = controller ? (0, utils_1.didyoumean)(actionName, controller.methods) : null;
        const suggestion = match ? `Did you mean "${match}"?` : "";
        this.pushDiagnostic(`"${actionName}" isn't a valid Controller Action on the "${identifier}" controller. ${suggestion}`, "stimulus.controller.action.invalid", range, textDocument, { identifier, actionName });
    }
    createAttributeFormatMismatchDiagnosticFor(identifier, valueName, textDocument, range) {
        this.pushDiagnostic(`The data attribute for "${valueName}" on the "${identifier}" controller is camelCased, but should be dasherized ("${(0, utils_1.dasherize)(valueName)}"). Please use dashes for Stimulus data attributes.`, "stimulus.attribute.mismatch", range, textDocument, { identifier, valueName });
    }
    createMissingValueOnControllerDiagnosticFor(identifier, valueName, textDocument, range) {
        const controller = this.controllers.find((controller) => controller.identifier === identifier);
        const match = controller ? (0, utils_1.didyoumean)(valueName, Object.keys(controller.values)) : null;
        const suggestion = match ? `Did you mean "${match}"?` : "";
        this.pushDiagnostic(`"${valueName}" isn't a valid Stimulus Value name on the "${identifier}" controller. ${suggestion}`, "stimulus.controller.value.missing", range, textDocument, { identifier, valueName });
    }
    createMissingTargetOnControllerDiagnosticFor(identifier, targetName, textDocument, range) {
        const controller = this.controllers.find((controller) => controller.identifier === identifier);
        const match = controller ? (0, utils_1.didyoumean)(targetName, controller.targets) : null;
        const suggestion = match ? `Did you mean "${match}"?` : "";
        this.pushDiagnostic(`"${targetName}" isn't a valid Stimulus Target on the "${identifier}" controller. ${suggestion}`, "stimulus.controller.target.missing", range, textDocument, { identifier, targetName });
    }
    createValueMismatchOnControllerDiagnosticFor(identifier, valueName, expectedType, actualType, textDocument, range) {
        this.pushDiagnostic(`The value you passed for the "${valueName}" Stimulus Value is of type "${actualType}". But the "${valueName}" Stimulus Value defined in the "${identifier}" controller is of type "${expectedType}".`, "stimulus.controller.value.type_mismatch", range, textDocument, { identifier, valueName });
    }
    pushDiagnostic(message, code, range, textDocument, data = {}, severity = node_1.DiagnosticSeverity.Error) {
        const diagnostic = {
            source: this.diagnosticsSource,
            severity,
            range,
            message,
            code,
            data,
        };
        const diagnostics = this.diagnostics.get(textDocument) || [];
        diagnostics.push(diagnostic);
        this.diagnostics.set(textDocument, diagnostics);
    }
    sendDiagnosticsFor(textDocument) {
        const diagnostics = this.diagnostics.get(textDocument) || [];
        this.connection.sendDiagnostics({
            uri: textDocument.uri,
            diagnostics,
        });
        this.diagnostics.delete(textDocument);
    }
    parseValueType(string) {
        switch (typeof string) {
            case "boolean":
                return "Boolean";
            case "number":
                return "Number";
            case "string":
                return "String";
        }
        if (Array.isArray(string))
            return "Array";
        if (Object.prototype.toString.call(string) === "[object Object]")
            return "Object";
    }
}
exports.Diagnostics = Diagnostics;
//# sourceMappingURL=diagnostics.js.map